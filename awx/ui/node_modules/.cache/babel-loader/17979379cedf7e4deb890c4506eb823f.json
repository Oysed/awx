{"ast":null,"code":"/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport var HeaderRow = function HeaderRow(_ref) {\n  var rowData = _ref.rowData,\n    rowIndex = _ref.rowIndex,\n    renderers = _ref.renderers,\n    _ref$onRow = _ref.onRow,\n    onRow = _ref$onRow === void 0 ? function () {\n      return {};\n    } : _ref$onRow;\n  return React.createElement(renderers.row, onRow(rowData, {\n    rowIndex: rowIndex\n  }), rowData.map(function (column, columnIndex) {\n    var property = column.property,\n      _column$header = column.header,\n      header = _column$header === void 0 ? {} : _column$header,\n      _column$props = column.props,\n      props = _column$props === void 0 ? {} : _column$props;\n    var evaluatedProperty = property || header && header.property;\n    var label = header.label,\n      _header$transforms = header.transforms,\n      transforms = _header$transforms === void 0 ? [] : _header$transforms,\n      _header$formatters = header.formatters,\n      formatters = _header$formatters === void 0 ? [] : _header$formatters,\n      _header$info = header.info,\n      info = _header$info === void 0 ? {} : _header$info;\n    var extraParameters = {\n      columnIndex: columnIndex,\n      property: evaluatedProperty,\n      column: column\n    };\n    var transformedProps = evaluateTransforms(transforms, label, extraParameters);\n    if (!transformedProps) {\n      // tslint:disable-next-line:no-console\n      console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n    }\n\n    var cellNode;\n    var tooltip = info.tooltip,\n      tooltipProps = info.tooltipProps,\n      popover = info.popover,\n      popoverProps = info.popoverProps,\n      ariaLabel = info.ariaLabel,\n      className = info.className;\n    // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n    // especially for sorting tables that use `transforms: [sortable]`\n    // {\n    //   title: 'Repositories',\n    //   header: {\n    //     info: {\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }\n    //   }\n    // }\n    //\n    // {\n    //   title: 'Repositories',\n    //   transforms: [\n    //     info({\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }),\n    //     sortable\n    //   ]\n    // },\n    if (tooltip) {\n      cellNode = React.createElement(HeaderCellInfoWrapper, {\n        variant: \"tooltip\",\n        info: tooltip,\n        tooltipProps: tooltipProps,\n        ariaLabel: ariaLabel,\n        className: className\n      }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n    } else if (popover) {\n      cellNode = React.createElement(HeaderCellInfoWrapper, {\n        variant: \"popover\",\n        info: popover,\n        popoverProps: popoverProps,\n        ariaLabel: ariaLabel,\n        className: className\n      }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n    } else {\n      cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n    }\n    return React.createElement(renderers.cell, Object.assign({\n      key: \"\".concat(columnIndex, \"-header\")\n    }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n  }));\n};\nHeaderRow.displayName = 'HeaderRow';","map":{"version":3,"names":["React","evaluateFormatters","evaluateTransforms","mergeProps","HeaderCellInfoWrapper","HeaderRow","_ref","rowData","rowIndex","renderers","_ref$onRow","onRow","createElement","row","map","column","columnIndex","property","_column$header","header","_column$props","props","evaluatedProperty","label","_header$transforms","transforms","_header$formatters","formatters","_header$info","info","extraParameters","transformedProps","console","warn","cellNode","tooltip","tooltipProps","popover","popoverProps","ariaLabel","className","variant","children","cell","Object","assign","key","concat","displayName"],"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-table/src/components/Table/base/header-row.tsx"],"sourcesContent":["/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { createElementType, ColumnType, HeaderType, RowsType, RendererType } from './types';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\n\nexport interface HeaderRowProps {\n  rowData: RowsType;\n  rowIndex: number;\n  renderers: RendererType;\n  onRow?: Function;\n}\n\nexport const HeaderRow: React.FunctionComponent<HeaderRowProps> = ({\n  rowData,\n  rowIndex,\n  renderers,\n  onRow = () => ({})\n}: HeaderRowProps) =>\n  React.createElement(\n    renderers.row as createElementType,\n    onRow(rowData, { rowIndex }),\n    (rowData as []).map((column: ColumnType, columnIndex: number) => {\n      const { property, header = {} as HeaderType, props = {} } = column;\n      const evaluatedProperty = property || (header && header.property);\n      const { label, transforms = [], formatters = [], info = {} } = header;\n      const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column\n      };\n      const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n\n      if (!transformedProps) {\n        // tslint:disable-next-line:no-console\n        console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n      }\n\n      let cellNode;\n      const { tooltip, tooltipProps, popover, popoverProps, ariaLabel, className } = info;\n      // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n      // especially for sorting tables that use `transforms: [sortable]`\n      // {\n      //   title: 'Repositories',\n      //   header: {\n      //     info: {\n      //       tooltip: 'More information about repositories',\n      //       className: 'repositories-info-tip',\n      //       tooltipProps: {\n      //         isContentLeftAligned: true\n      //       }\n      //     }\n      //   }\n      // }\n      //\n      // {\n      //   title: 'Repositories',\n      //   transforms: [\n      //     info({\n      //       tooltip: 'More information about repositories',\n      //       className: 'repositories-info-tip',\n      //       tooltipProps: {\n      //         isContentLeftAligned: true\n      //       }\n      //     }),\n      //     sortable\n      //   ]\n      // },\n      if (tooltip) {\n        cellNode = (\n          <HeaderCellInfoWrapper\n            variant=\"tooltip\"\n            info={tooltip}\n            tooltipProps={tooltipProps}\n            ariaLabel={ariaLabel}\n            className={className}\n          >\n            {transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)}\n          </HeaderCellInfoWrapper>\n        );\n      } else if (popover) {\n        cellNode = (\n          <HeaderCellInfoWrapper\n            variant=\"popover\"\n            info={popover}\n            popoverProps={popoverProps}\n            ariaLabel={ariaLabel}\n            className={className}\n          >\n            {transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)}\n          </HeaderCellInfoWrapper>\n        );\n      } else {\n        cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n      }\n\n      return React.createElement(\n        renderers.cell as createElementType,\n        {\n          key: `${columnIndex}-header`,\n          ...mergeProps(props, header && header.props, transformedProps)\n        },\n        cellNode\n      );\n    })\n  );\nHeaderRow.displayName = 'HeaderRow';\n"],"mappings":"AAAA;;;;;;AAMA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,kBAAkB,QAAQ,uBAAuB;AAC1D,SAASC,kBAAkB,QAAQ,uBAAuB;AAC1D,SAASC,UAAU,QAAQ,eAAe;AAE1C,SAASC,qBAAqB,QAAQ,0BAA0B;AAShE,OAAO,IAAMC,SAAS,GAA4C,SAArDA,SAASA,CAAAC,IAAA;EAAA,IACpBC,OAAO,GAAAD,IAAA,CAAPC,OAAO;IACPC,QAAQ,GAAAF,IAAA,CAARE,QAAQ;IACRC,SAAS,GAAAH,IAAA,CAATG,SAAS;IAAAC,UAAA,GAAAJ,IAAA,CACTK,KAAK;IAALA,KAAK,GAAAD,UAAA,cAAG;MAAA,OAAO,EAAE;IAAA,CAAC,GAAAA,UAAA;EAAA,OAElBV,KAAK,CAACY,aAAa,CACjBH,SAAS,CAACI,GAAwB,EAClCF,KAAK,CAACJ,OAAO,EAAE;IAAEC,QAAQ,EAARA;EAAQ,CAAE,CAAC,EAC3BD,OAAc,CAACO,GAAG,CAAC,UAACC,MAAkB,EAAEC,WAAmB,EAAI;IAC9D,IAAQC,QAAQ,GAA4CF,MAAM,CAA1DE,QAAQ;MAAAC,cAAA,GAA4CH,MAAM,CAAhDI,MAAM;MAANA,MAAM,GAAAD,cAAA,cAAG,EAAgB,GAAAA,cAAA;MAAAE,aAAA,GAAiBL,MAAM,CAArBM,KAAK;MAALA,KAAK,GAAAD,aAAA,cAAG,EAAE,GAAAA,aAAA;IACvD,IAAME,iBAAiB,GAAGL,QAAQ,IAAKE,MAAM,IAAIA,MAAM,CAACF,QAAS;IACjE,IAAQM,KAAK,GAAkDJ,MAAM,CAA7DI,KAAK;MAAAC,kBAAA,GAAkDL,MAAM,CAAtDM,UAAU;MAAVA,UAAU,GAAAD,kBAAA,cAAG,EAAE,GAAAA,kBAAA;MAAAE,kBAAA,GAAiCP,MAAM,CAArCQ,UAAU;MAAVA,UAAU,GAAAD,kBAAA,cAAG,EAAE,GAAAA,kBAAA;MAAAE,YAAA,GAAgBT,MAAM,CAApBU,IAAI;MAAJA,IAAI,GAAAD,YAAA,cAAG,EAAE,GAAAA,YAAA;IAC1D,IAAME,eAAe,GAAG;MACtBd,WAAW,EAAXA,WAAW;MACXC,QAAQ,EAAEK,iBAAiB;MAC3BP,MAAM,EAANA;KACD;IACD,IAAMgB,gBAAgB,GAAG7B,kBAAkB,CAACuB,UAAU,EAAEF,KAAK,EAAEO,eAAe,CAAC;IAE/E,IAAI,CAACC,gBAAgB,EAAE;MACrB;MACAC,OAAO,CAACC,IAAI,CAAC,uDAAuD,CAAC,CAAC,CAAC;;;IAGzE,IAAIC,QAAQ;IACZ,IAAQC,OAAO,GAAgEN,IAAI,CAA3EM,OAAO;MAAEC,YAAY,GAAkDP,IAAI,CAAlEO,YAAY;MAAEC,OAAO,GAAyCR,IAAI,CAApDQ,OAAO;MAAEC,YAAY,GAA2BT,IAAI,CAA3CS,YAAY;MAAEC,SAAS,GAAgBV,IAAI,CAA7BU,SAAS;MAAEC,SAAS,GAAKX,IAAI,CAAlBW,SAAS;IAC1E;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIL,OAAO,EAAE;MACXD,QAAQ,GACNlC,KAAA,CAAAY,aAAA,CAACR,qBAAqB;QACpBqC,OAAO,EAAC,SAAS;QACjBZ,IAAI,EAAEM,OAAO;QACbC,YAAY,EAAEA,YAAY;QAC1BG,SAAS,EAAEA,SAAS;QACpBC,SAAS,EAAEA;MAAS,GAEnBT,gBAAgB,CAACW,QAAQ,IAAIzC,kBAAkB,CAAC0B,UAAU,CAAC,CAACJ,KAAK,EAAEO,eAAe,CAAC,CAEvF;KACF,MAAM,IAAIO,OAAO,EAAE;MAClBH,QAAQ,GACNlC,KAAA,CAAAY,aAAA,CAACR,qBAAqB;QACpBqC,OAAO,EAAC,SAAS;QACjBZ,IAAI,EAAEQ,OAAO;QACbC,YAAY,EAAEA,YAAY;QAC1BC,SAAS,EAAEA,SAAS;QACpBC,SAAS,EAAEA;MAAS,GAEnBT,gBAAgB,CAACW,QAAQ,IAAIzC,kBAAkB,CAAC0B,UAAU,CAAC,CAACJ,KAAK,EAAEO,eAAe,CAAC,CAEvF;KACF,MAAM;MACLI,QAAQ,GAAGH,gBAAgB,CAACW,QAAQ,IAAIzC,kBAAkB,CAAC0B,UAAU,CAAC,CAACJ,KAAK,EAAEO,eAAe,CAAC;;IAGhG,OAAO9B,KAAK,CAACY,aAAa,CACxBH,SAAS,CAACkC,IAAyB,EAAAC,MAAA,CAAAC,MAAA;MAEjCC,GAAG,KAAAC,MAAA,CAAK/B,WAAW;IAAS,GACzBb,UAAU,CAACkB,KAAK,EAAEF,MAAM,IAAIA,MAAM,CAACE,KAAK,EAAEU,gBAAgB,CAAC,GAEhEG,QAAQ,CACT;EACH,CAAC,CAAC,CACH;AAAA;AACH7B,SAAS,CAAC2C,WAAW,GAAG,WAAW"},"metadata":{},"sourceType":"module"}